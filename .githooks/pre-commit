#!/bin/bash
# Enhanced Pre-commit hook for comprehensive quality enforcement
# StarsCalendars Quality Guardian - Zero Tolerance for Anti-patterns

set -euo pipefail

echo "ğŸ›¡ï¸ Quality Guardian: Comprehensive quality enforcement..."
echo "ğŸ“Š Checking $(git diff --cached --name-only | wc -l) files for quality violations"
if [ -n "${SKIP_PRECOMMIT:-}" ]; then
    echo "âš ï¸  SKIP_PRECOMMIT set - skipping checks"
    exit 0
fi

# Performance timer for quality checks
start_time=$(date +%s.%N)

# Color codes for better visibility
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

ERRORS_FOUND=0
WARNINGS_FOUND=0

# Function to log errors with timestamps
log_error() {
    echo -e "${RED}âŒ BLOCKED [$(date '+%H:%M:%S')]: $1${NC}"
    ERRORS_FOUND=1
}

# Function to log warnings
log_warning() {
    echo -e "${YELLOW}âš ï¸  WARNING [$(date '+%H:%M:%S')]: $1${NC}"
    WARNINGS_FOUND=1
}

# Function to log success
log_success() {
    echo -e "${GREEN}âœ… PASSED [$(date '+%H:%M:%S')]: $1${NC}"
}

# Function to log info
log_info() {
    echo -e "${BLUE}ğŸ” CHECKING [$(date '+%H:%M:%S')]: $1${NC}"
}

# Get list of staged Rust files (excluding astro-rust)
STAGED_RS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.rs$' | grep -v 'astro-rust/' || true)

if [ -z "$STAGED_RS_FILES" ]; then
    log_info "No Rust files to check"
else
    log_info "Checking $(echo "$STAGED_RS_FILES" | wc -l) Rust files"
fi
# JS/TS anti-patterns (warnings only locally)
if [ -f "scripts/anti-patterns-js.sh" ]; then
    log_info "JS/TS anti-pattern scan (staged)"
    if bash scripts/anti-patterns-js.sh >/tmp/js_scan.out 2>&1; then
        log_success "JS/TS anti-patterns clean"
    else
        log_warning "JS/TS anti-patterns found; see /tmp/js_scan.out"
        cat /tmp/js_scan.out | sed 's/^/    /' | head -40
    fi
fi

# Secret baseline scan (warnings only locally)
if [ -f "scripts/secret-scan.sh" ]; then
    log_info "Secret baseline scan"
    if bash scripts/secret-scan.sh >/tmp/secret_scan.out 2>&1; then
        log_success "Secret scan clean"
    else
        log_warning "Potential secrets found; see /tmp/secret_scan.out"
        cat /tmp/secret_scan.out | sed 's/^/    /' | head -40
    fi
fi

# ğŸš¨ CRITICAL ANTI-PATTERNS - Rust 1.89+ Standards
log_info "Scanning for critical anti-patterns..."

# Enhanced forbidden patterns with context
declare -A FORBIDDEN_PATTERNS=(
    ["\.unwrap\(\)"]="Use Result<T, E> with proper error handling"
    ["\.expect\("]="Use Result<T, E> with custom error types"
    ["panic!\("]="Use Result<T, E> - never panic in production"
    ["HashMap::new\(\)"]="Use HashMap::with_capacity(n) for O(1) performance"
    ["Vec::new\(\)"]="Use Vec::with_capacity(n) for pre-allocation"
    ["BTreeMap::new\(\)"]="Use BTreeMap::new() only if capacity unknown"
    ["HashSet::new\(\)"]="Use HashSet::with_capacity(n) for performance"
    ["VecDeque::new\(\)"]="Use VecDeque::with_capacity(n) for performance"
    ["\\bunsafe\\b"]="Unsafe code forbidden except in WASM contexts"
    ["todo!\(\)"]="Remove todo!() before committing"
    ["unimplemented!\(\)"]="Complete implementation before committing"
    ["unreachable!\(\)"]="Use proper error handling instead"
)

# Check each pattern in staged files
for pattern in "${!FORBIDDEN_PATTERNS[@]}"; do
    if [ -n "$STAGED_RS_FILES" ]; then
        violations=$(echo "$STAGED_RS_FILES" | xargs grep -n "$pattern" 2>/dev/null || true)
        if [ -n "$violations" ]; then
            log_error "Found forbidden pattern: $pattern"
            echo "  ğŸ“ Suggestion: ${FORBIDDEN_PATTERNS[$pattern]}"
            echo "  ğŸ“ Violations:"
            echo "$violations" | sed 's/^/    /'
            echo
        fi
    fi
done

# ğŸ¯ WASM PERFORMANCE PATTERNS - O(1) Hot Path Enforcement
log_info "Validating WASM performance patterns..."

if git diff --cached --name-only | grep -q "wasm-astro"; then
    log_info "WASM changes detected - validating O(1) hot path requirement"

    # Check for multiple compute_state calls per frame
    if git diff --cached | grep -B5 -A5 "compute_state" | grep -q "for\\|while\\|loop"; then
        log_error "Multiple WASM calls detected - violates O(1) hot path requirement"
        echo "  ğŸ“ Requirement: Exactly ONE compute_state(t) call per frame"
        echo "  ğŸ”§ Use thread-local buffers with Float64Array view"
    else
        log_success "WASM O(1) hot path pattern validated"
    fi

    # Check for string passing between WASM-JS (forbidden)
    if git diff --cached | grep -q "wasm.*String\\|String.*wasm"; then
        log_error "String passing between WASM-JS detected"
        echo "  ğŸ“ Requirement: Use numbers only, no string marshaling"
    fi

    # Check for missing thread-local buffers
    if git diff --cached | grep -q "compute_state" && ! git diff --cached | grep -q "thread_local"; then
        log_warning "WASM compute_state without thread_local buffer pattern"
        echo "  ğŸ“ Suggestion: Use thread_local buffers for zero-copy data transfer"
    fi
fi

# ğŸ”„ ASYNC PERFORMANCE PATTERNS - Real-time Context Validation
log_info "Validating async performance patterns..."

# Check for .await in loops (blocking in real-time context)
if git diff --cached | grep -B3 -A3 "for\\|while\\|loop" | grep -q "\.await"; then
    log_error ".await in loop detected - blocking operation in real-time context"
    echo "  ğŸ“ Requirement: Use parallel processing with join_all() or spawn tasks outside loop"
    echo "  ğŸ”§ Pattern: let futures: Vec<_> = items.iter().map(|i| async_fn(i)).collect();"
    echo "           let results = join_all(futures).await;"
fi

# ğŸ—ï¸ CLEAN ARCHITECTURE VALIDATION
log_info "Validating Clean Architecture compliance..."

# Check domain layer dependencies
if echo "$STAGED_RS_FILES" | grep -q "libs/domain/" && git diff --cached | grep -q "use.*infrastructure\\|use.*app"; then
    log_error "Domain layer depends on outer layers - Clean Architecture violation"
    echo "  ğŸ“ Rule: Domain must only depend on itself and std library"
fi

# Check for direct database usage in use-cases
if echo "$STAGED_RS_FILES" | grep -q "libs/app/" && git diff --cached | grep -q "use.*postgres\\|use.*sqlx::Pool"; then
    log_error "Use-case directly uses database - should use repository trait"
    echo "  ğŸ“ Pattern: Define trait in domain, implement in infrastructure"
fi

# ğŸ”’ SECURITY VALIDATION
log_info "Validating security patterns..."

# Check for potential SQL injection
if git diff --cached | grep -i "format!" | grep -qi "select\\|insert\\|update\\|delete"; then
    log_error "Potential SQL injection - string formatting with SQL keywords"
    echo "  ğŸ“ Requirement: Use sqlx::query! or sqlx::query_as! macros only"
fi

# Check for hardcoded secrets
if git diff --cached | grep -qi "password.*=\\|token.*=\\|secret.*=\\|key.*=" | grep -v "_test\\|_example"; then
    log_warning "Potential hardcoded secret detected"
    echo "  ğŸ“ Use environment variables or secure configuration"
fi

# Check for proper JWT validation
if echo "$STAGED_RS_FILES" | grep -q "backend/" && git diff --cached | grep -q "jwt" && ! git diff --cached | grep -q "RS256"; then
    log_warning "JWT usage without RS256 validation pattern"
    echo "  ğŸ“ Requirement: Use RS256 signatures for JWT validation"
fi

# ğŸŒ INTERNATIONALIZATION VALIDATION
log_info "Validating i18n compliance..."

# Check for hardcoded English strings
if git diff --cached | grep -o '"[A-Za-z ]{10,}"' | grep -v "test\\|debug\\|error\\|log" >/dev/null 2>&1; then
    log_warning "Potential hardcoded English strings detected"
    echo "  ğŸ“ Requirement: Use t!() macro for all user-facing text"
    echo "  ğŸ”§ Pattern: t!(\"key\", args) for 10-language support"
fi

# ğŸ“Š PERFORMANCE MONITORING
log_info "Performance checks completed"

# Check for inefficient string operations
if git diff --cached | grep -q "to_string().*+\\|format!.*+"; then
    log_warning "Inefficient string concatenation detected"
    echo "  ğŸ“ Use format! macro or String::with_capacity() + push_str()"
fi

# Check for missing error handling in main functions
if git diff --cached | grep -A10 "fn main()" | grep -q "unwrap\\|expect\\|panic!"; then
    log_error "Error handling issues in main() function"
    echo "  ğŸ“ Use proper error handling even in main()"
fi

# ğŸ¯ FINAL VALIDATION AND REPORTING
end_time=$(date +%s.%N)
check_duration=$(echo "$end_time - $start_time" | bc -l)

echo
echo "ğŸ“Š QUALITY GUARDIAN REPORT"
echo "========================="
echo "â±ï¸  Check Duration: $(printf "%.2f" $check_duration)s"
echo "ğŸ“ Files Checked: $(echo "$STAGED_RS_FILES" | wc -l | tr -d ' ')"
echo "âŒ Errors Found: $ERRORS_FOUND"
echo "âš ï¸  Warnings Found: $WARNINGS_FOUND"
echo

if [ $ERRORS_FOUND -gt 0 ]; then
    echo -e "${RED}ğŸš« COMMIT BLOCKED${NC}"
    echo "Fix all errors above and try again."
    echo
    echo "ğŸ’¡ Quick fixes:"
    echo "  â€¢ Replace .unwrap() with proper error handling"
    echo "  â€¢ Use HashMap::with_capacity() instead of HashMap::new()"
    echo "  â€¢ Move .await calls outside of loops"
    echo "  â€¢ Follow Clean Architecture dependency rules"
    echo
    echo "ğŸ”§ Run 'make quality-check' for detailed analysis"
    exit 1
fi

if [ $WARNINGS_FOUND -gt 0 ]; then
    echo -e "${YELLOW}âš ï¸  COMMIT ALLOWED WITH WARNINGS${NC}"
    echo "Consider addressing warnings for production-grade quality."
else
    echo -e "${GREEN}âœ… ALL QUALITY CHECKS PASSED${NC}"
fi

echo -e "${GREEN}ğŸ‰ Ready to commit! Quality Guardian approved.${NC}"
exit 0
